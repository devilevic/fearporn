<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>fearporn.world</title>

    <!-- Your static CSS is served at root: /style.css -->
    <link rel="stylesheet" href="/style.css" />
  </head>

  <body>
    <header class="header">
      <div class="header-row">
        <div class="brand">
          <h1 class="site-title">
            fearporn<span class="dot">.</span><span class="accent">world</span>
          </h1>
          <p class="tagline">bringing out the worst humanity has to offer</p>
        </div>

        <!-- Theme toggle on the right, same row -->
        <button id="themeToggle" class="theme-toggle" type="button" aria-label="Toggle theme">
          <span id="themeIcon" class="theme-icon">ðŸŒ™</span>
          <span id="themeLabel">DARK</span>
        </button>
      </div>
    </header>

    <main class="container">
      <div id="articles"></div>

      <nav class="pagination" id="pagination"></nav>
    </main>

    <!-- Your theme script -->
    <script src="/theme.js"></script>

    <script>
      const PAGE_SIZE = 10;

      function escapeHtml(str) {
        return String(str ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      // âœ… Removes the *extra* "Source: ..." lines that the model may have printed inside the summary
      // while keeping the dedicated bottom source line (rendered separately from article metadata).
      function stripInlineSources(summary) {
        let s = String(summary ?? "");

        // remove lines that start with "Source:" (case-insensitive)
        s = s.replace(/^Source:\s*.*$/gmi, "");

        // collapse excessive blank lines caused by removals
        s = s.replace(/\n{3,}/g, "\n\n").trim();

        return s;
      }

      function formatDate(iso) {
        if (!iso) return "";
        // keep your current look; donâ€™t over-format
        try {
          const d = new Date(iso);
          if (isNaN(d.getTime())) return iso;
          return d.toISOString().slice(0, 19).replace("T", " ");
        } catch {
          return iso;
        }
      }

      async function fetchArticles(page) {
        const offset = (page - 1) * PAGE_SIZE;
        const res = await fetch(`/api/articles?limit=${PAGE_SIZE}&offset=${offset}`);
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        return await res.json();
      }

      async function fetchTotal() {
        // If your backend supports it, great. If not, we fallback to using _debug.
        // _debug already reports total/summarized counts.
        const res = await fetch("/_debug");
        if (!res.ok) return null;
        const data = await res.json();
        // we only paginate summarized articles
        return data?.summarized ?? null;
      }

      function renderArticles(rows) {
        const root = document.getElementById("articles");
        root.innerHTML = "";

        for (const a of rows) {
          const category = escapeHtml(a.category || "world");
          const ts = escapeHtml(formatDate(a.summarized_at || a.created_at || a.published_at));
          const title = escapeHtml(a.title || "");
          const summaryClean = stripInlineSources(a.summary || "");
          const summaryHtml = escapeHtml(summaryClean).replace(/\n/g, "<br/>");

          const sourceDomain = escapeHtml(a.source_domain || "");
          const url = a.url || "";

          const card = document.createElement("article");
          card.className = "card";

          card.innerHTML = `
            <div class="meta">
              <span class="pill">${category}</span>
              <span class="dotsep">â€¢</span>
              <span class="ts">${ts}</span>
            </div>

            <h2 class="title">
              ${title}
            </h2>

            <div class="summary">${summaryHtml}</div>

            <div class="source">
              Source: <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${sourceDomain}</a>
            </div>
          `;

          root.appendChild(card);
        }
      }

      function renderPagination(currentPage, totalPages) {
        const nav = document.getElementById("pagination");
        nav.innerHTML = "";

        if (!totalPages || totalPages <= 1) return;

        const makeBtn = (label, page, disabled = false, active = false) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = label;
          btn.className = active ? "page-btn active" : "page-btn";
          btn.disabled = disabled;
          btn.addEventListener("click", () => setPage(page));
          return btn;
        };

        nav.appendChild(makeBtn("Prev", Math.max(1, currentPage - 1), currentPage === 1));

        // compact pagination: 1 â€¦ 3 4 5 â€¦ N
        const pages = [];
        pages.push(1);
        for (let p = currentPage - 2; p <= currentPage + 2; p++) {
          if (p > 1 && p < totalPages) pages.push(p);
        }
        if (totalPages > 1) pages.push(totalPages);

        const unique = [...new Set(pages)].sort((a, b) => a - b);

        let last = 0;
        for (const p of unique) {
          if (p - last > 1) {
            const span = document.createElement("span");
            span.className = "ellipsis";
            span.textContent = "â€¦";
            nav.appendChild(span);
          }
          nav.appendChild(makeBtn(String(p), p, false, p === currentPage));
          last = p;
        }

        nav.appendChild(
          makeBtn("Next", Math.min(totalPages, currentPage + 1), currentPage === totalPages)
        );
      }

      async function setPage(page) {
        const rows = await fetchArticles(page);
        renderArticles(rows);

        const totalSummarized = await fetchTotal();
        if (totalSummarized != null) {
          const totalPages = Math.max(1, Math.ceil(totalSummarized / PAGE_SIZE));
          renderPagination(page, totalPages);
        }
      }

      // Theme toggle UI (uses localStorage key "theme" if your theme.js does)
      function syncThemeButton() {
        const t = localStorage.getItem("theme") || document.documentElement.dataset.theme || "dark";
        const isDark = (t === "dark");

        document.getElementById("themeIcon").textContent = isDark ? "ðŸŒ™" : "â˜€ï¸";
        document.getElementById("themeLabel").textContent = isDark ? "DARK" : "LIGHT";
      }

      document.getElementById("themeToggle").addEventListener("click", () => {
        const current = localStorage.getItem("theme") || "dark";
        const next = (current === "dark") ? "light" : "dark";
        localStorage.setItem("theme", next);

        // apply immediately (works even if theme.js is simple)
        document.documentElement.dataset.theme = next;

        syncThemeButton();
      });

      // initial load
      syncThemeButton();
      setPage(1);
    </script>
  </body>
</html>